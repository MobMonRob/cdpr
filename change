[1mdiff --git a/cdpr_controllers/src/control_qp.cpp b/cdpr_controllers/src/control_qp.cpp[m
[1mdeleted file mode 100644[m
[1mindex ed2bdc2..0000000[m
[1m--- a/cdpr_controllers/src/control_qp.cpp[m
[1m+++ /dev/null[m
[36m@@ -1,191 +0,0 @@[m
[31m-#include <cdpr_controller/cdpr4qp.h>[m
[31m-#include <cdpr_controller/qp_slover.h>[m
[31m-[m
[31m-using namespace std;[m
[31m-//using namespace gazebo;[m
[31m-[m
[31m-[m
[31m-/*[m
[31m- * Feedback linearization controller to show input/output of the CDPR class[m
[31m- *[m
[31m- * Combine with the qp slover to get optimal force[m
[31m- *[m
[31m- *[m
[31m- */[m
[31m-[m
[31m-[m
[31m-void Param(ros::NodeHandle &nh, const string &key, double &val)[m
[31m-{[m
[31m-    if(nh.hasParam(key))[m
[31m-        nh.getParam(key, val);[m
[31m-    else[m
[31m-        nh.setParam(key, val);[m
[31m-} [m
[31m-[m
[31m-int main(int argc, char ** argv)[m
[31m-{[m
[31m-[m
[31m-    // precision 4 on 1.23456 you get 1.234 [m
[31m-    cout.precision(3);[m
[31m-    // init ROS node[m
[31m-    ros::init(argc, argv, "cdpr_qp_control");[m
[31m-    ros::NodeHandle nh;[m
[31m-[m
[31m-[m
[31m-    // load model parameters  ??????[m
[31m-    //ros::NodeHandle model(nh, "model");[m
[31m-     CDPR robot(nh);[m
[31m-    const unsigned int n = robot.n_cables();[m
[31m-[m
[31m-    [m
[31m-    vpMatrix W(6, n);   // tau = W.T + g[m
[31m-    vpColVector g(6), tau(6), err, err_p, err_a,T(n), err_d(6),b(6),r,d;[m
[31m-    g[2] = - robot.mass() * 9.81;[m
[31m-    vpMatrix RR(6,6), RR_p(6,6);[m
[31m-    double dt = 0.01;[m
[31m-    ros::Rate loop(1/dt);[m
[31m-    vpHomogeneousMatrix M, Md, Md_p;[m
[31m-    vpRotationMatrix R, R_p;[m
[31m-    vpQuaternionVector q;[m
[31m-    vpTranslationVector t_d,t;[m
[31m-    vpMatrix C, M_inertia(6,6),Q;[m
[31m-    double fmin,fmax;[m
[31m-    [m
[31m-    // initialize the qp_slover matrix[m
[31m-    // minimize matrix[m
[31m-    r.resize(n);[m
[31m-    d.resize(2*n);[m
[31m-    Q.resize(n,n);[m
[31m-    C.resize(2*n,n);[m
[31m-[m
[31m-    // objective function matrix[m
[31m-    for(unsigned int i=0;i<n;++i)[m
[31m-        for(unsigned int k=0;k<n;++k)[m
[31m-           Q[i][k]=1;[m
[31m-[m
[31m-    // inequality matrix[m
[31m-    for(unsigned int i=0;i<n;++i)[m
[31m-        for(unsigned int k=0;k<n;++k)[m
[31m-        {[m
[31m-           C[i][k]=1;[m
[31m-           C[i+n][k]=-1;[m
[31m-        }[m
[31m-[m
[31m-    robot.tensionMinMax(fmin,fmax);[m
[31m-    for(unsigned int i=0;i<n;++i)[m
[31m-        {[m
[31m-            d[i]=fmax;[m
[31m-            d[i+n]=-fmin;[m
[31m-        }[m
[31m-[m
[31m-    // gain[m
[31m-    double Kp = 50, Kd = 50;  // Ki = 0.5, tuned for Caroca[m
[31m-    Param(nh, "Kp", Kp);[m
[31m-    // Param(nh, "Ki", Ki);[m
[31m-    Param(nh, "Kd", Kd);[m
[31m-    [m
[31m-    // previous desired matrix[m
[31m-    robot.getInitialPose(Md_p);[m
[31m-    cout << "CDPR control ready" << fixed << endl;[m
[31m-    while(ros::ok())[m
[31m-    {[m
[31m-        cout << "------------------" << endl;[m
[31m-        nh.getParam("Kp", Kp);[m
[31m-        //nh.getParam("Ki", Ki);[m
[31m-         nh.getParam("Kd", Kd);[m
[31m-[m
[31m-        [m
[31m-         [m
[31m-        if(robot.ok())   // messages have been received[m
[31m-        {[m
[31m-[m
[31m-[m
[31m-            // current position[m
[31m-            robot.getPose(M);[m
[31m-            M.extract(R);[m
[31m-            M.extract(t);[m
[31m-[m
[31m-            // deisired position ??????[m
[31m-            robot.getDesiredPose(Md);[m
[31m-           [m
[31m-            // position error in platform frame[m
[31m-            err = robot.getPoseError();[m
[31m-            cout << "Position error in platform frame: " << err.t() << fixed << endl;[m
[31m-            // RR is one 6x6 matrix[m
[31m-            for(unsigned int i=0;i<3;++i)[m
[31m-                for(unsigned int j=0;j<3;++j)[m
[31m-                    RR[i][j] = RR[i+3][j+3] = R[i][j];[m
[31m-[m
[31m-            // calculate the desired acceleration[m
[31m-            err_p= robot.getDesiredPoseError(Md_p,Md);[m
[31m-            Md_p.extract(R_p);[m
[31m-            Md_p=Md;[m
[31m-            for(unsigned int i=0;i<3;++i)[m
[31m-                for(unsigned int j=0;j<3;++j)[m
[31m-                    RR_p[i][j] = RR_p[i+3][j+3] = R_p[i][j];[m
[31m-[m
[31m-[m
[31m-            // position error in fixed frame[m
[31m-            err = RR * err;[m
[31m-            // desired pose error between previous and current position in fixed frame[m
[31m-            err_p= RR_p * err_p;[m
[31m-[m
[31m-            for(unsigned int i=0;i<6;++i)[m
[31m-                // the desired acceleration[m
[31m-                err_a[i] = err_p[i] / (dt*dt);[m
[31m-[m
[31m-            // I term to wrench in fixed frame[m
[31m-            for(unsigned int i=0;i<6;++i)[m
[31m-                //if(tau[i] < robot.mass()*9.81)[m
[31m-                    //calculate the difference of velocity[m
[31m-                    err_d[i] = err[i] / dt;[m
[31m-            M_inertia=robot.inertia();[m
[31m-[m
[31m-            // create the qp matrix equality constraint[m
[31m-            b=-(M_inertia*(err_a+Kp*err+Kd*err_d)+g);[m
[31m-            // build W matrix depending on current attach points[m
[31m-            robot.computeW(W);[m
[31m-[m
[31m-            //solve_qp::solveQP(Q,r,W,b,C,d,T);[m
[31m-            //T=W.pseudoInverse()*b;[m
[31m-            [m
[31m-            // Closed form method[m
[31m-            // f_m= (f_max+f_min)/2;[m
[31m-            // T= f_m-W.pseudoInverse()*(-b + (W*f_m));[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
[31m-	        //cout << "Desired force in platform frame: " << T.t() << fixed << endl;[m
[31m-            cout << " The tesion in cables: " << T.t() << endl;[m
[31m-                [m
[31m-            //tau = Kp * (err + Ki*err_i);[m
[31m-            // position error in fixed frame[m
[31m-            //tau = fRRp * tau;[m
[31m-            // PI controller to wrench in fixed frame[m
[31m-           /* tau_i += tau * dt;[m
[31m-            tau = Kp * (tau + Ki*tau_i);[m
[31m-            cout << "Desired wrench in platform frame: " << (fRRp.transpose()*(tau - g)).t() << fixed << endl;[m
[31m-           */[m
[31m-            // solve problem : tau = T.u + g[m
[31m-            //qp_r = fRRp.transpose() * (tau-g);[m
[31m-            //qp.solveCascade(u);[m
[31m-            //u = T.pseudoInverse() * fRRp.transpose()* (tau - g);[m
[31m-            //cout << "   Verif W.f+g in platform frame: " << (T*u).t() << fixed << endl;[m
[31m-            //u = 0.5*(u+u0);[m
[31m-            //u0 = u;[m
[31m-[m
[31m-           // write effort to jointstate[m
[31m-           cout << "sending tensions: " << T.t() << endl;[m
[31m-           // send tensions[m
[31m-           robot.sendTensions(T);[m
[31m-[m
[31m-        }[m
[31m-[m
[31m-        ros::spinOnce();[m
[31m-        loop.sleep();[m
[31m-    }[m
[31m-[m
[31m-[m
[31m-}[m
